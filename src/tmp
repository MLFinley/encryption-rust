use crate::z26::Letter;

struct Rule {
    encrypt: fn(String) -> String,
    decrypt: fn(String) -> String,
}

struct LetterRule {
    encrpt: fn(Letter) -> Letter,
    decrypt: fn(Letter) -> Letter,
}




// impl From<LetterRule> for Rule {
//     fn from(letter_rule: LetterRule) -> Self {
//         let encrypt_for_each = |s| enc(letter_rule.encrpt, s);
//         Rule { encrypt: |s| enc(letter_rule, s), decrypt:  }
//     }
// }

fn apply_letter_rule<F> (func: F, c: char) -> char 
where
    F: Fn(Letter) -> Letter 
{
    Letter::try_from(c)
        .map(func) 
        .map(char::from)
        .unwrap_or_else(|c| c)
}

fn letter_map<F,G>(func: F) -> impl Fn(String) -> String + 'static
where
    F: Fn(Letter) -> Letter
{
    let char_map = |c: char| apply_letter_rule(func, c);
    let str_map = |s: String| -> String {s.chars().map(char_map).collect::<String>()};
    str_map
}

pub fn caeser(letter: Letter) -> Letter {
    letter + 3.into()
}